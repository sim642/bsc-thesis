\documentclass[../thesis.tex]{subfiles}

\begin{document}

\section{Domeeni omadused}

\subsection{Võre omadused}
Kuna nõutakse, et domeenid oleks täielikud võred, siis peavadki nad kõiksugu võrede tingimusi rahuldama. Järgnev on ülevaade erinevatest omadustest, mis täielikel võredel kehtima peaks:

\noindent
Olgu $\mathbb{D}$ täielik võre, siis iga $a, b, c \in \mathbb{D}$ korral peavad kehtima järgnevad tingimused:

\paragraph{Osalise järjestuse omadused} (definitsioonist~\ref{def:järjestatud_hulk})
\begin{itemize}[nosep]
	\item $a \sqleq a$ (refleksiivsus);
	\item kui $a \sqleq b$ ja $b \sqleq c$, siis $a \sqleq c$ (transitiivsus);
	\item kui $a \sqleq b$ ja $b \sqleq a$, siis $a = b$ (antisümmeetrilisus);
\end{itemize}

\paragraph{Rajade omadused}~\cite{might_orders}
\begin{itemize}[nosep]
	\item $a \sqleq a \sqcup b$ ja $b \sqleq a \sqcup b$ (definitsioonist~\ref{def:join});
	\item $a \sqcap b \sqleq a$ ja $a \sqcap b \sqleq b$ (definitsioonist~\ref{def:meet});
	\item kui $a \sqleq c$ ja $b \sqleq c$, siis $a \sqcup b \sqleq c$ (definitsioonist~\ref{def:join});
	\item kui $c \sqleq a$ ja $c \sqleq b$, siis $c \sqleq a \sqcap b$ (definitsioonist~\ref{def:meet});
\end{itemize}

\paragraph{Rajade tehete omadused}~\cites[6]{laan_voreteooria}[39]{davey_lattices}
\begin{itemize}[nosep]
	\item $(a \sqcup b) \sqcup c = a \sqcup (b \sqcup c)$ ja $(a \sqcap b) \sqcap c = a \sqcap (b \sqcap c)$ (assotsiatiivsus);
	\item $a \sqcup b = b \sqcup a$ ja $a \sqcap b = b \sqcap a$ (kommutatiivsus);
	\item $a \sqcup a = a$ ja $a \sqcap a = a$ (idempotentsus);
	\item $a \sqcup (a \sqcap b) = a$ ja $a \sqcap (a \sqcup b) = a$ (neelduvus);
\end{itemize}

\paragraph{Vähima ja suurima elemendi omadused}~\cite{might_orders}
\begin{itemize}[nosep]
	\item $\bot \sqleq a$;
	\item $a \sqleq \top$;
	\item $a \sqcup \bot = a$;
	\item $a \sqcap \top = a$;
\end{itemize}

\paragraph{Järjestuse ja rajade tehete seosed}
Järgnevad on ekvivalentsed~\cite[39]{davey_lattices}:
\begin{enumerate}[nosep]
	\item $a \sqleq b$,
	\item $a \sqcup b = b$,
	\item $a \sqcap b = a$.
\end{enumerate}


\subsection{Laiendamine ja kitsendamine}
Kui joonisel~\ref{fig:prog-if} olev programm oli tsükliteta ja selle analüüsi saaks teostada ka ilma võrratuste süsteemi püsipunkti leidmata teostada, siis üldiselt see nii pole. Huvitavamad programmid sisaldavad tsükleid, mille korral ülalkirjeldatud algoritm on analüüsimiseks vajalik. Olgu vaatluse all programm jooniselt~\ref{fig:prog-while} ja domeen $\mathbb{D} = (\Var \to \mathbb{I})_\bot$ nagu enne, siis võrratuste ja võrrandite süsteemid on järgnevad:
\[
	\begin{cases}
		x_1 \sqgeq \top \\
		\begin{comment}
		\begin{rcases*}
			x_2 \sqgeq \tf_{1,2}(x_1) \\
			x_2 \sqgeq \tf_{3,2}(x_3)
		\end{rcases*} \Rightarrow
		\end{comment}
		x_2 \sqgeq \tf_{1,2}(x_1) \sqcup \tf_{3,2}(x_3) \\
		x_3 \sqgeq \tf_{2,3}(x_2) \\
		x_4 \sqgeq \tf_{2,4}(x_2)
	\end{cases}
	\quad \text{ja} \quad
	\begin{cases}
		x_1 = \top \\
		x_2 = \tf_{1,2}(x_1) \sqcup \tf_{3,2}(x_3) = \\ \quad\: = x_1[\texttt{x} \mapsto [0, 0]] \sqcup x_3[\texttt{x} \mapsto d(\texttt{x}) + [1, 1]] \\ % TODO proper align
		x_3 = \tf_{2,3}(x_2) = x_2[\texttt{x} \mapsto d(\texttt{x}) \sqcap [-\infty, 99]] \\
		x_4 = \tf_{2,4}(x_2) = x_2[\texttt{x} \mapsto d(\texttt{x}) \sqcap [100, +\infty]]
	\end{cases}.
\]

Nende vähim püsipunkt (tabelis~\ref{tab:while-iter}) leitakse naiivse iteratsiooni 204. sammul. Itereerimisel sisuliselt tehakse läbi kõik 100 tsükli iteratsiooni, mistõttu sellise süsteemi püsipunkti leidmise ajaline keerukus on $O(k)$, kus $k$ on tsükli iteratsioonide arv. Selline ebaefektiivsus on vastuvõetamatu, sest toimub justkui programmi kogu töö simuleerimine, mis on vastuolus staatilise analüüsi eesmärgiga.

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\begin{minted}{c}
			int x = 0;
			while (x < 100)
				x++;
		\end{minted}
		\TODO{kood eraldi faili?}
		\caption{C-keelne lähtekood}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\begin{tikzpicture}[
			->,>=stealth,
			node distance=0.75cm,
			every state/.style={inner sep=3pt, minimum size=0pt},
			stmt/.style={font=\ttfamily},
			initial text={},
			initial where=above
		]
			\node[initial,state] (1) {1};
			\node[state] (2) [below=of 1] {2};
			\node[state] (3) [below left=of 2] {3};
			\node[accepting,state] (4) [below right=of 2] {4};

			\path
				(1) edge node[stmt,right] {x = 0} (2)
				(2) edge[bend right] node[stmt,above left,near start] {x < 100} (3)
				    edge node[stmt,above right] {x >= 100} (4)
				(3) edge[bend right] node[stmt,below right,very near start] {x++} (2);
		\end{tikzpicture}
		\TODO{tikz eraldi .tex faili?}
		\caption{Juhtimisvoograaf}
	\end{subfigure}

	\caption{Tsükliga programmi näidis.}
	\label{fig:prog-while}
\end{figure}

\paragraph{Laiendamine}
Ebaefektiivsuses on süüdi asjaolu, et intervalldomeenis leiduvad \emph{lõpmatud rangelt kasvavad ahelad}.
\TODO{Selgitada kuidagi ahelaid}
Püsipunkti leidmise igal iteratsioonil tsüklis muutuja väärtuste lõik suurenes ühe võrra seetõttu stabiliseerumiseks läks ebameeldivalt palju iteratsioone. Probleemi lahendamiseks muudetakse analüüsimist nii, et püsipunkti leidmine toimuks kiirendatult, tuues meelega sisse täiendava ebatäpsuse. Sellist võtet nimetatakse \emph{laiendamiseks} (ingl. \textit{widening}).

Lahendatav võrratus $\bar{x} \sqgeq \bar{f}(\bar{x})$ kirjutatakse samaväärsel akumuleerival kujul $\bar{x} = \bar{x} \sqcup \bar{f}(\bar{x})$, kus ülemraja asemele valitakse sobiv \emph{laiendamise operaator} $\widen$ ja otsitakse vähim püsipunkt võrrandile $\bar{x} = \bar{x} \widen \bar{f}(\bar{x})$. Intervallidel defineeritakse see järgnevalt:
\begin{gather*}
	[l_1, u_1] \widen [l_2, u_2] = [l, u], \text{ kus} \\
	l = \begin{cases}
		l_1, & \text{kui } l_1 \leq l_2, \\
		-\infty, & \text{muidu}
	\end{cases}
	\qquad \text{ja} \qquad
	u = \begin{cases}
		u_1, & \text{kui } u_2 \leq u_1, \\
		+\infty, & \text{muidu}.
	\end{cases}
\end{gather*}
Intervallide laiendamise idee seiseb selles, et intervall suurenedes suureneb kohe vastavas suunas lõpmatusse, garanteerides, et intervall saab suureneda ülimalt kaks korda, mis muudab kasvavad ahelad lõplikeks. Sellise modifikatsiooniga süsteemi vähim püsipunkt (tabelis~\ref{tab:while-widen}) leitakse juba naiivse iteratsiooni 6. sammul, mis ühest küljest on oluline võit, teisest kaotus, sest lahend pole nii täpne kui eelnevalt.

\paragraph{Kitsendamine}
Kuna $\bar{f}$ on monotoonne, siis selle rakendamine püsipunktile tulemust ebatäpsemaks ei muuda, aga võib ebatäpset laiendatud tulemust siiski parandada. Sellist võtet nimetatakse \emph{kitsendamiseks} (ingl. \textit{narrowing}) ning eelmisele laiendatud lahendile kitsendamist rakendades stabiliseerub tulemus (tabelis~\ref{tab:while-narrow}) 4. sammul, jõudes sama tulemuseni, mis ilma laiendamist ja kitsendamist. Üldiselt see siiski nii ei pruugi olla, kuid tulemuse täpsust suurendab ikka.

Kitsendamisel võib tekkida analoogiline probleem \emph{lõpmatute rangelt kahanevate ahelatega}, mistõttu funktsiooni korduv rakendamine mõistliku sammude arvuga ei stabiliseeru. Samas võib kitsendamist võib lõpetada mistahes hetkel ja analüüs on ikka korrektne. Kitsendamise stabiliseerumiseks kasutatakse analoogilist võtet: lahendatav võrratus kirjutatakse samaväärsel kujul $\bar{x} = \bar{x} \sqcap \bar{f}(\bar{x})$, kus alamraja asemele valitakse sobiv \emph{kitsendamise operaator} $\narrow$ ja otsitakse vähim püsipunkt võrrandile $\bar{x} = \bar{x} \narrow \bar{f}(\bar{x})$. Intervallidel defineeritakse see järgnevalt:
\begin{gather*}
	[l_1, u_1] \narrow [l_2, u_2] = [l, u], \text{ kus} \\
	l = \begin{cases}
		l_2, & \text{kui } l_1 = -\infty, \\
		l_1, & \text{muidu}
	\end{cases}
	\qquad \text{ja} \qquad
	u = \begin{cases}
		u_2, & \text{kui } u_1 = +\infty, \\
		u_1, & \text{muidu}.
	\end{cases}
\end{gather*}
Intervallide kitsendamise idee seiseb selles, et intervall vähenedeb ainult lõpmatusest, garanteerides, et intervall saab väheneda ülimalt kaks korda, mis muudab kahanevad ahelad lõplikeks. Uuritud näitel kiirendatud kitsendamine jõuab sama tulemuseni kui tavaline kitsendamine (tabelis~\ref{tab:while-narrow}). Üldiselt see nii ei pruugi olla, sest kiirendamisel tuuakse sisse meelega täiendav ebatäpsus.

\begin{table}
	\caption{Näiteprogrammi (joonisel~\ref{fig:prog-while}) analüüsi lahendid erinevatel meetoditel.}
	\centering
	\begin{subtable}[t]{0.3\textwidth}
		\caption{Iteratsiooni lahend}
		\centering
		$\begin{tabu}{c|c}
		\hline
		 & \texttt{x} \\
		\hline
		x_1 & \top \\
		x_2 & [0, 100] \\
		x_3 & [0, 99] \\
		x_4 & [100, 100] \\
		\hline
		\end{tabu}$
		\label{tab:while-iter}
	\end{subtable}
	~
	\begin{subtable}[t]{0.3\textwidth}
		\caption{Laiendamise tulemus}
		\centering
		$\begin{tabu}{c|c}
		\hline
		 & \texttt{x} \\
		\hline
		x_1 & \top \\
		x_2 & [0, +\infty] \\
		x_3 & [0, +\infty] \\
		x_4 & [100, +\infty] \\
		\hline
		\end{tabu}$
		\label{tab:while-widen}
	\end{subtable}
	~
	\begin{subtable}[t]{0.3\textwidth}
		\caption{Kitsendamise tulemus}
		\centering
		$\begin{tabu}{c|c}
		\hline
		 & \texttt{x} \\
		\hline
		x_1 & \top \\
		x_2 & [0, 100] \\
		x_3 & [0, 99] \\
		x_4 & [100, 100] \\
		\hline
		\end{tabu}$
		\label{tab:while-narrow}
	\end{subtable}
	\label{tab:itersolve-while}
\end{table}

\paragraph{Omadused}
Laiendamise ja kitsendamise operaatorid peavad analüüsi korrektsuse tagamiseks rahuldama teatud tingimusi.

\noindent
Olgu $\mathbb{D}$ abstraktne domeen, siis iga $a, b \in \mathbb{D}$ korral peavad kehtima järgnevad tingimused:
\begin{itemize}[nosep]
	\item $a \sqcup b \sqleq a \widen b$ \cite[61]{seidl_foundations};
	\item $a \sqcap b \sqleq a \narrow b \sqleq a$ \cite[66]{seidl_foundations}.
\end{itemize}

Kusjuures need operaatorid pole tingimata assotsiatiivsed, kommutatiivsed, jne nagu nende algsed analoogid. Neid kasutatakse nii nagu ülal toodud, kus vasak operand on vana seisund ja parem operand on uus seisund. Sellel asjaolul põhineb nende defineerimine ja seda ka nähtud intervalldomeeni puhul.

\subsection{Abstraktsiooni korrektsus}
\cite[242]{cousot77}
\TODO{Galois ühendused vms.}


\end{document}