\documentclass[../thesis.tex]{subfiles}

\begin{document}

\section{Omaduspõhine testimine}
Omaduspõhine testimine (ingl. \textit{property-based testing}) on programmide testimise metoodika, mis põhineb soovitud omaduste verifitseerimisel juhuslikult genereeritud testandmetel. Selle lähenemise populariseeris Haskelli teek nimega QuickCheck, mis on nüüdseks implementeeritud ka paljude teiste programmeerimiskeelte jaoks ja mille kasutamine on funktsionaalprogrammeerimises laialdane.

Omaduspõhine testimine sobib hästi matemaatilist laadi omaduste, nagu eelmises peatükis toodud domeenide omaduste, kontrollimiseks, sest seda saab teha lihtsa tingimusega, vajamata sobivate testandmete väljamõtlemist. See võimaldab samu omadusi kontrollida kõigil domeenidel, sõltumata isegi nende elementide tüübist.

\subsection{Põhimõtted}
Testitavad omadused kirjeldatakse predikaatidena, millele omaduspõhise testimise raamistik genereerib hulga juhuslikke argumente, millel arvutab välja predikaadi väärtuse. Kui see on kõigil genereeritud argumentidel tõene, siis loetakse test läbituks ja omadus kehtivaks. Kui mõnel argumendil on predikaat väär, loetakse test läbikukkunuks ja omadus mittekehtivaks. Viimasel juhul kuvatakse probleemne argument ka testijale.

Omaduspõhise testimise raamistikes on tüüpiliselt juba defineeritud, kuidas vastava keele põhiliste andmetüüpide, sh paaride, järjendite jne, väärtusi juhuslikult genereerida. Puuduvate ja enda defineeritud andmetüüpide jaoks tuleb see ise juurde lisada. Seejuures \enquote{juhuslik} ei pea tähendama täielikult juhuslikku protsessi, vaid võib alati genereerida ka hulka huvitavaid ja sageli probleeme tekitavaid erijuhte (nt arv null, tühi järjend jne).

Juhuslikult genereeritud argumendid võivad olla \enquote{suured}: suured arvud, pikad sõned või järjendid, sügavad puud jne. Võib kergesti juhtuda, et mõne omaduse kontranäide on seetõttu inimese jaoks raskesti hoomatav ja jääb ebaselgeks, mis on selle argumendi juures erilist, et omadus ei kehti. Vigade analüüsimise lihtsustamiseks kasutatakse omaduspõhises testimises vääravate argumentide lihtsustamist ehk vähendamist (ingl. \textit{shrinking}). Kirjeldatakse, kuidas leitud väärtusest saada lihtsamaid, mis oleks algsega piisavalt sarnased, et nende korral võiks omadus samuti mitte kehtida. Näiteks järjendist mingite elementide eemaldamine, et pikkus sellest väheneks. Vähendatud argumentidel väärtustatakse predikaat uuesti, leidmaks neid, mille korral omadus ikka ei kehti, ja rakendatakse vähendamist taas nii palju kordi kui võimalik, et lihtsustada probleemset argumenti maksimaalselt, muutes selle paremini hoomatavaks.

Tüüpiliselt on ka põhiliste andmetüüpide vähendaminie testimisraamistikesse juba sisse ehitatud, aga sedagi on võimalik ise laiendada oma andmetüüpidele.

\subsection{Goblint}
Goblint on mitmelõimeliste C programmide staatiline analüsaator, mis keskendub andmejooksude tuvastamisele \cite{goblint2016}. Seda tehakse andmevooanalüüsi raamistikus, kasutades keerukamaid spetsiifilisi abstraktseid domeene. Goblinti autoritele on teada, et analüsaator ei käitu alati oodatud viisil, vaid võib teha vigu. Üheks võimalikuks probleemide allikaks on kasutusel olevad abstraktsed domeenid ja täpsemalt nende implementatsioonid. Leidmaks nende vigade allikat, testitigi käesoleva töö raames Goblintis implementeeritud domeenide omadusi.

Goblint ise on kirjutatud OCaml-is ja on avatud lähtekoodiga~\cite{goblint_repo}. Selle omaduspõhiseks testimiseks valiti vastav OCaml-i teek QCheck~\cite{qcheck_repo}, mis on sarnaste teekide hulgast enim kasutatud ja uuendatud.

\begin{figure}
	\centering
	\begin{bminted}[mathescape]{ocaml}
		module type S =
		sig
		  type t (* domeeni elementide tüüp *)
		  val equal: t -> t -> bool (* seos $=$ *)
		  val leq: t -> t -> bool (* seos $\sqleq$ *)
		  val join: t -> t -> t (* tehe $\sqcup$ *)
		  val meet: t -> t -> t (* tehe $\sqcap$ *)
		  val bot: unit -> t (* element $\bot$ *)
		  val is_bot: t -> bool
		  val top: unit -> t (* element $\top$ *)
		  val is_top: t -> bool
		  val widen: t -> t -> t (* tehe $\widen$ *)
		  val narrow: t -> t -> t (* tehe $\narrow$ *)
		end
	\end{bminted}
	\caption{Domeeni (lihtsustatud) signatuur Goblinti moodulis \texttt{Lattice}.}
	\label{fig:lattice-s}
\end{figure}

Goblintis on domeenid implementeeritud OCaml-i moodulitena, mis muu hulgas sisaldavad domeeni elemendi tüüpi ning neil defineeritud seoseid ja tehteid, nagu näidatud joonisel~\ref{fig:lattice-s}. Domeenide omaduste testimiseks on esmalt vaja defineerida selle elementide generaator. Selleks lisati domeeni signatuuri järgneva signatuuriga funktsioon:
\begin{minted}{ocaml}
	val arbitrary: unit -> t QCheck.arbitrary
\end{minted}

Igas domeenis defineeritav \texttt{t QCheck.arbitrary} hõlmab endas nii tüüpi \texttt{t} elementide generaatorit (\texttt{t QCheck.Gen}) kui ka vähendajat (\texttt{t QCheck.Shrink}).

Kõik eelmises peatükis toodud omadused implementeeriti omaduspõhiste testidena moodulis \texttt{DomainProperties}. Näiteks ülemraja kommutatiivsuse test näeb välja järgmiselt:
\begin{minted}{ocaml}
let join_comm = make ~name:"join comm" (pair arb arb)
                  (fun (a, b) -> D.equal (D.join a b) (D.join b a))
\end{minted}
kus \texttt{D} on testitava domeeni moodul ja \texttt{arb} on mugavuse mõttes \texttt{D.arbitrary ()}.

Testid implementeeriti polümorfselt OCaml-i funktorite abil, mis võimaldab samu omadusi kontrollida mistahes domeenil. See oligi eesmärk, sest kõik need omadused peavad universaalselt kehtima. Domeeni testimiseks peab sellel siiski olema defineeritud \texttt{arbitrary}, mida saab teha üksnes manuaalselt ja mis seega on kõige ajamahukam osa Goblinti arvukate domeenide testimise juures. Sellele läheneti kahelt poolt.

\subsection{Alt-üles lähenemine}
Ühest küljest testiti erinevaid täisarvudega töötavaid domeene moodulist \texttt{IntDomain}, mis on üsna sõltumatud ja seetõttu saab neid eraldiseisvalt testida. Paljud teised domeenid kasutavad oma elementidena konkreetsest analüüsitavast programmist leitud muutujaid, funktsioone vms, mis teeb nende testimise raskeks, sest pole selge, kust võtta juhuslikke elemente. Täisarvude abstraktsioonide puhul seda probleemi ei esine.

Nende testimiseks loodi moodul \texttt{Maindomaintest}, mida saab Goblintist endast eraldi kompileerida (käsuga \texttt{make domaintest}) ja käivitada (käsuga \texttt{./goblint.domaintest -v}). Selles moodulis on nimekiri domeenidest, mida käivitamisel testitakse.

\subsection{Ülalt-alla lähenemine}
Teisest küljest testiti domeeni, mida Goblint päriselt etteantud programmi analüüsimisel kasutama hakkaks. See domeen pannakse erinevate seadistuste abil kokku paljudest domeenidest, mis oma osadena kasutavad teisi lihtsamaid domeene (nagu seda teeb kujutusdomeen), mis omakorda võivad olla veelgi lihtsamatest domeenidest komponeeritud. Sellised sõltuvusi arvestades saab analüüsiks kasutatavat domeeni ette kujutada kui puud, mille lehtedeks on lihtsad sõltuvusteta domeenid nagu eelnevalt testitud täisarvude domeenid. Kui alt-üles lähenemise puhul testiti sellise puu lehti, siis ülalt-alla lähenemises testitakse domeene alustades juurest.

Juurdomeeni elementide genereerimiseks oleks põhimõtteliselt vaja genereerida elemente kõigist teistest domeenidest, millest sõltutakse. See eeldab korraga kõigi Goblinti domeenide jaoks generaatorite lisamist, mis lisaks suurele töömahule võib olla ka ebaotstarbekas. Kui mingite alamdomeenide generaatorid defineerida triviaalselt, näiteks alati $\bot$ genereerimise teel, siis on võimalik tervet domeeni testida, ilma et oleks vaja kõiki generaatoreid lisada, sest mingite alamdomeenide elemente pole vaja genereerida. Selliselt testitigi domeenide hierarhia ülemist osa.
\TODO{Mingi näide kõrgemat järku domeenist ja selle sõltuvustest/alamdomeenidest?}

Selliselt testimiseks lisati Goblinti käsurealippude hulka uus nimega \texttt{dbg.test.domain}. Kui see on sisse lülitatud, siis enne etteantud programmi analüüsimist jooksutatakse analüüsiks kasutataval domeenil samad testid. Goblinti näidiskäivitus koos selle lipuga toimub järgneva käsuga:
\begin{minted}{bash}
	./goblint --enable dbg.test.domain \
	    ./tests/regression/04-mutex/01-simple_rc.c
\end{minted}

\TODO{Testimise tulemused}


\end{document}