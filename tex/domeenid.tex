\documentclass[../thesis.tex]{subfiles}

\begin{document}

\section{Abstraktsed domeenid}
\TODO{Pikem üleminek sissejuhatusest domeenide juurde}

Andmevooanalüüsiga püütakse võimalikult täpselt määrata programmi seisundit igas programmi punktis.

\begin{definition}
\emph{Domeeniks} nimetatakse programmi kõikvõimalike seisundite hulka~\cite{vojdani_magister}.
\end{definition}

Selline informaalne definitsioon on ebapiisav mingisuguse teooria arendamiseks, mistõttu tegelikult vaadetakse domeene, mis moodustavad täieliku võre.

\subsection{Andmevooanalüüs}
Andmevooanalüüsi ja abstraktse interpretatsiooni põhimõtete selgitamiseks parim viis on näite läbitegemine. Selleks olgu edaspidi vaatluse all programm jooniselt~\ref{fig:prog-if}, kus on kõrvuti C-keelse lähtekoodi jupp ja selle juhtimisvoograaf, mille tippudes on programmi punktid, milles seisundeid uuritakse, ja servadel vastavad laused, mida täidetakse.
Järgnevalt on käsitsi analüüsitud selle programmi täisarvuliste muutujate võimalike väärtusi igas programmi punktis:
\begin{itemize}
	\item Punktis 1 pole muutujaid deklareeritud, seega nende väärtustest ei saa rääkida.
	\item Punktis 2 muutuja \texttt{x} väärtust üheselt määrata pole võimalik, sest see tuleb juhuarvu funktsioonist \texttt{rand()}, kuid jäägiga jagamise tulemusena kuulub see kindlasti hulka $\{0, 1, 2\}$\footnote{C keele semantika on siinkohal keerukas, kuid (üldiselt võimalikud) negatiivsed jäägid on antud juhul välistatud, sest \texttt{rand()} funktsioon ei tagasta negatiivseid arve.}.
	Lisaks on vahepeal deklareeritud väärtustamata muutuja \texttt{y}, millel C keele semantikas vaikeväärtust pole ja seetõttu võib selle väärtus olla suvaline täisarv, st suvaline hulgast $\mathbb{Z}$ \cite{C11_draft}.
	\item Punktis 3, kus tingimus oli tõene, on \texttt{x} kindlasti ainult 0.
	\item Punktis 4, kus tingimus oli väär, saab eelnevast hulgast välistatud nulli eemaldamisel öelda, et muutuja \texttt{x} väärtus on hulgas $\{1, 2\}$.
	\item Punktis 5 on täpselt teada, et \texttt{y} on 5.
	\item Punktis 6, teades võimalikke muutuja \texttt{x} väärtusi, saab öelda, et muutuja \texttt{y} väärtus tehte tulemusena on hulgas $\{2, 3\}$.
	\item Punktis 7, kus kaks võimalikku tingimuslause haru uuesti kokku saavad, tuleb arvestada mõlema haru võimalike väärtustega, seega muutuja \texttt{y} väärtus kuulub hulka $\{2, 3, 5\}$.
	\item Punktis 8, teades võimalikke \texttt{y} väärtusi, saab öelda, et muutuja \texttt{z} väärtus tehte tulemusena on hulgas $\{4, 6, 10\}$.
\begin{comment}
	\item Punktides 1, 2 ja 3 on muutuja veel väärtustamata. Kuna C keele semantika sellisel juhul mingit vaikeväärtust ei anna, siis võimalikke väärtusi kirjeldab kõige ebatäpsem domeeni element $\top = \mathbb{Z}$.
	\item Punktis 4 on muutujale just antud konstantne väärtus, mistõttu seda kirjeldab kõige paremini element $\{5\}$.

		Iseenesest poleks vale seostada selle programmi punktiga mõnda (osalise järjestuse järgi) üldisemat seisundit, nt $\{5, 6, 7\}$ või lausa $\top$, kuid see poleks nii kasulik, sest analüüsi mõte on siiski leida võimalikult täpne kirjeldus. Just selle täpsuse matemaatiliseks kirjeldamiseks nõutaksegi osalist järjestust.
	\item Punktiga 5 sobib samal põhjusel seostada element $\{3\}$.
	\item Punktis 6 on olukord huvitavam, sest seda seisundit pole programmis oleva hargnemise (täpsemalt selle ühendumise) tõttu kirjeldada ühe täisarvuga, vaid elemendiga $\{3, 5\}$. Selle tulemuseni jõudmiseks peab intuitiivselt ühendama eelneva kahe punkti seisundid --- leidma seisundi, mis hõlmaks eelnevaid, olles seejuures võimalikult täpne. Just selleks nõutaksegi ülemise raja leidmise tehet, millega seda teha. Antud juhul $\{3\} \sqcup \{5\} = \{3, 5\}$.
\end{comment}
\end{itemize}

Tehtud analüüs on võimalikult täpne, mis oleks ka automatiseeritud analüüsi eesmärgiks. Iseenesest poleks vale mõnes programmi punktis mõne muutujaga seostada suuremat võimalike väärtuste hulka, kuid sellisest analüüsist oleks vähem kasu, sest see tooks sisse ebavajalikku ebatäpsust.
Järgnevalt ongi eesmärk matemaatiliselt formaliseerida sellise hea analüüsi teostamine, mis omakorda oleks aluseks analüüsi teoreetiliseks uurimiseks ja automatiseerimiseks.

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\begin{minted}{c}
			int x = rand() % 3;
			int y;
			if (x == 0)
				y = 5;
			else
				y = x + 1;
			int z = 2 * y;
		\end{minted}
		\TODO{kood eraldi faili?}
		\caption{C-keelne lähtekood}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\begin{tikzpicture}[
			->,>=stealth,
			node distance=0.5cm,
			every state/.style={inner sep=3pt, minimum size=0pt},
			stmt/.style={font=\ttfamily},
			initial text={},
			initial where=above
		]
			\node[initial,state] (1) {1};
			\node[state] (2) [below=of 1] {2};
			\node[state] (3) [below left=of 2] {3};
			\node[state] (4) [below right=of 2] {4};
			\node[state] (5) [below=of 3] {5};
			\node[state] (6) [below=of 4] {6};
			\node[state] (7) [below right=of 5] {7};
			\node[accepting,state] (8) [below=of 7] {8};

			\path
				(1) edge node[stmt,right] {x = rand() \% 3} (2)
				(2) edge node[stmt,above left] {x == 0} (3)
				    edge node[stmt,above right] {x != 0} (4)
				(3) edge node[stmt,left] {y = 5} (5)
				(4) edge node[stmt,right] {y = x + 1} (6)
				(5) edge node {} (7)
				(6) edge node {} (7)
				(7) edge node[stmt,right] {z = 2 * y} (8);
		\end{tikzpicture}
		\TODO{tikz eraldi .tex faili?}
		\caption{Juhtimisvoograaf}
	\end{subfigure}

	\caption{Tsüklita programmi näidis.}
	\label{fig:prog-if}
\end{figure}


\subsection{Võred}
Domeenide kirjeldamiseks kasutatakse matemaatilisi struktuure, mida nimetatakse võredeks. Kuigi võreteooria on arvestatav matemaatika haru, siis sügavamale laskumata on siin toodud vajalikud mõisted võredest aru saamiseks.
Järgnevad eestikeelsed definitsioonid on refereeritud V. Laane loengukonspektist aines \enquote{Võreteooria}~\cite{laan_voreteooria}, kuid tähistused on kohandatud programmianalüüsi kirjandusele omaseks~\cite[17]{seidl_foundations}:

\begin{definition}
\label{def:järjestatud_hulk}
\emph{Osaliselt järjestatud hulk} on paar $(A, \sqleq)$, kus $A$ on hulk, millel on defineeritud binaarne seos $\sqleq$, mis iga $a, b, c \in A$ korral rahuldab järgnevaid tingimusi:
\begin{itemize}[nosep]
	\item $a \sqleq a$ (refleksiivsus),
	\item kui $a \sqleq b$ ja $b \sqleq c$, siis $a \sqleq c$ (transitiivsus),
	\item kui $a \sqleq b$ ja $b \sqleq a$, siis $a = b$ (antisümmeetrilisus).
\end{itemize}
\end{definition}

Domeenide puhul kasutatakse osalist järjestust seisundite täpsuse võrdlemiseks. Kokkuleppeliselt järjestatakse seisundid täpsemast ebatäpsema suunas --- kirjutis $a \sqleq b$ tähendab, et seisund $a$ kirjeldab programmi olekut täpsemalt või sama täpselt kui seisund $b$. Teiste sõnadega, alati kui programmi olekut kirjeldab $a$, siis saab seda kirjeldada ka $b$-ga.

\noindent
Järgnevalt olgu $(A, \sqleq)$ osaliselt järjestatud hulk ja $X \subseteq A$.

\begin{definition}
\label{def:join}
Elementi $c$ nimetatakse hulga $X$ \emph{ülemiseks tõkkeks}, kui iga $x \in X$ korral $x \sqleq c$. Vähimat ülemist tõket nimetatakse \emph{ülemiseks rajaks}, st $X$-i iga ülemise tõkke $d$ korral $c \sqleq d$.
\end{definition}

\begin{definition}
\label{def:meet}
Elementi $c$ nimetatakse hulga $X$ \emph{alumiseks tõkkeks}, kui iga $x \in X$ korral $c \sqleq x$. Suurimat alumist tõket nimetatakse \emph{alumiseks rajaks}, st $X$-i iga alumise tõkke $d$ korral $d \sqleq c$.
\end{definition}

Hulga $X$ ülemist ja alumist raja tähistatakse vastavalt $\bigsqcup X$ ja $\bigsqcap X$. Kui $X = \{a, b\}$, siis tähistatakse ülemine ja alumine raja vastavalt $a \sqcup b$ ja $a \sqcap b$.

Domeenide puhul kasutatakse ülemisi tõkkeid mitme seisundi ühendamiseks, nii nagu seda oli vaja teha joonise~\ref{fig:prog-if} programmi punktis 7. Seejuures tahetakse loomulikult täpseimat ühendatud seisundit, mis ongi ühendatavate seisundite ülemine raja.
\TODO{Milleks vaja alumist raja?}

\begin{definition}
\emph{Täielik võre} on osaliselt järjestatud hulk, mille igal alamhulgal leidub ülemine ja alumine raja.
\end{definition}

Täielikus võres $(A, \sqleq)$ leidub vähim element $\bot = \bigsqcap A$ ja suurim element $\top = \bigsqcup A$, mida nimetatakse vastavalt \textit{bottom}iks ja \textit{top}iks.

Domeenidelt nõutaksegi, et need oleks täielikud võred, sest sellega kaasnevad ülal kirjeldatud võimalused seisunditega töötamiseks. Domeeni element $\top$ kirjeldab kõige üldisemat seisundit ehk seisundit, kus pole programmi oleku kohta mitte midagi teada. Element $\bot$ kirjeldab võimatut seisundit ehk tüüpiliselt seda, et programmi täitmisel mitte kunagi uuritavasse punkti ei jõutagi.


\subsection{Alamhulkade domeen}
Iga hulga $S$ korral saab vaadelda selle kõigi alamhulkade hulka $\powerset{S}$, millel on loomulik osaline järjestus $\subseteq$.
Osutub, et see on ka täielik võre, kus
\begin{itemize}[nosep]
	\item $a \sqleq b \Leftrightarrow a \subseteq b$,
	\item $a \sqcup b = a \cup b$ ja $a \sqcap b = a \cap b$,
	\item $\bot = \emptyset$ ja $\top = S$.
\end{itemize}

Hulk $X$ kirjeldab väärtust $z$ parajasti siis, kui $z \in X$. Sellega on defineeritud, kuidas peaks seostama domeeni elemente konkreetsete võimalike väärtustega.
\TODO{\textit{Description relation} --- kas üldse mõtet mainida? Vb jätta Galois ühenduste juurde.}

Ülal käsitsi tehtud joonise~\ref{fig:prog-if} programmi analüüsis oligi iga muutuja väärtusi analüüsitud alamhulkade domeeni $\mathbb{D} = (\powerset{\mathbb{Z}}, \subseteq)$ abil. Programmi punktis 7 toimunud muutuja \texttt{y} seisundite ühendamine on võrede terminites $\{5\} \sqcup \{2, 3\}$. Antud programmi analüüsimiseks on selle domeeniga vaja seostada kahte tüüpi tehted:
\begin{description}
	\item[Konstantide abstraheerimine] Lause \texttt{y = 5} abstraktseks teostamiseks, st muutujaga~\texttt{y} domeeni elemendi seostamiseks, on esinev konstant vaja sobivalt abstraheerida. Täisarvude alamhulkade domeenis sobib konstantse väärtuse $a$ jaoks ilmselt element $\{a\}$.

	\item[Abstraktne aritmeetika] Lause \texttt{y = x + 1} abstraktseks teostamisks on vaja teostada liitmine muutuja \texttt{x} seisundi $\{1, 2\}$ ja konstandi seisundi $\{1\}$ vahel. Täisarvude alamhulkade domeenis saab elementide $A, B \in \powerset{\mathbb{Z}}$ liitmise defineerida kui
	\[
		A + B = \{a + b \mid a \in A, b \in B\}
	\]
	ning sarnaselt võib defineerida ülejäänud tehted.
\end{description}

Nende matemaatiliste vahenditega ongi võimalik näites tehtu süstematiseerida. Siiski kirjeldab kasutatud domeen korraga ainult ühe muutuja väärtuseid, kuid muutujatevahelisi toiminguid otseselt mitte --- seda peab ikkagi domeeniväliselt teostama. Oleks veelgi parem, kui tervet programmi olekut, st kõigi muutujate seisundeid korraga, saaks vaadelda ühe keerukama domeeni elementidena. Selleks võetaksegi kasutusele kujutused.


\TODO{Kujutusdomeen liigutada siia.}
\TODO{Algoritmilise analüüsi näide kujutusdomeeni peal.}


\subsection{Algoritmiline analüüs}
\TODO{Näide tervest analüüsist: +üleminekufunktsioonid +võrratuste süsteem +süsteemi lahendamine. Sama näite peal?}
Viimases näites tehtud analüüs oli manuaalne ja põhines suuresti intuitsioonil, kuid kogu analüüsi saab teostada ka automaatselt, sest vastav protsess on algoritmiliselt kirjeldatav. Esiteks peab olema fikseeritud domeen, mille abil analüüsi teostatakse ja mis on võimeline kirjeldama meid huvitavaid programmi omadusi.

Teiseks peab defineerima funktsioonid, mis teostavad kõikvõimalikke programmeerimiskeele lauseid (nt omistamine) abstraktsel tasemel.
\TODO{Parandada \textit{abstract edge effects} mõistet ja vajalikke omadusi.}

Kolmandaks tuleb iga programmi punkti jaoks võtta üks muutuja $x_i$, mis vastab otsitavale programmi abstraktsele seisundile selles punktis.

Neljandaks tuleb iga konkreetse juhtimisvoograafi serva järgi kirjeldada \emph{üleminekufunktsioon} $f_i: \mathbb{D}^n \to \mathbb{D}$, mis lausele eelneva punkti seisundi järgi leiab lausele järgneva punkti seisundi. Nõnda saab iga serva jaoks moodustada võrratuse $x_i \sqgeq f_i(x_1, \ldots, x_n)$.
\TODO{Eriline võrratus algtipu jaoks!}

Viiendaks saab moodustada kõigist võrratustest süsteemi, kus iga muutuja on vasakul täpselt ühel korral, selleks vajadusel võrratusi parema poole ülemraja järgi ühendades:
\[
	\begin{cases}
		x_1 \sqgeq f_1(x_1, \ldots, x_n), \\
		\vdots \\
		x_n \sqgeq f_n(x_1, \ldots, x_n).
	\end{cases}
\]
Sama saab lühemalt kirja panna, kui vaadelda hoopis täielikku võre $\mathbb{D}^n$, mille elementide positsioonil $i$ on programmi punkti $i$ seisund. Selle võre tehted on defineeritud punktiviisiliselt. Sellises võres on muutujaks $\bar{x} = (x_1, \ldots, x_n)$ ning üleminekufunktsioonid ühendatud kokku ühte funktsiooni $\bar{f}(\bar{x}) = (f_1(\bar{x}), \ldots, f_n(\bar{x}))$. Sellega on kogu eelnev võrratuste süsteem ühendatud üheks ainsaks võrratuseks $\bar{x} \sqgeq \bar{f}(\bar{x})$.

Kuuendaks tuleb saadud võrratusele (ehk kaudselt algsele võrratuste süsteemile) leida vähim lahend. Selle iga lahend on üks korrektne analüüs, mis iga programmi punkti kohta sisaldab selle abstraktset seisundit. Vähim sobiv lahend on ühtlasi täpseim võimalik analüüs, ehk see, millest enim kasu oleks.

Saab näidata, et see on samaväärne võrrandi $\bar{x} = \bar{f}(\bar{x})$ vähima lahendi leidmisega~\cite[21]{seidl_foundations}, mida nimetatakse ka vähima püsipunkti leidmiseks. Selleks on kõige lihtsam iteratiivne algoritm, mis alustab väärtusega $\bar{x}_0 = \overline{\bot} = (\bot, \ldots, \bot)$ ja järjest iga $\bar{x}_i$ korral arvutab $\bar{x}_{i+1} = \bar{f}(\bar{x}_i)$ kuni lõpuks jõutakse nii kaugele, et mingi $i$ korral $\bar{x}_i = \bar{x}_{i+1}$, st funktsiooni väärtused stabiliseeruvad ja funktsiooni edasi rakendamine tulemust ei muuda. Leitud lahendist ongi võimalik välja lugeda analüüsi tulemused iga programmi punkti jaoks.
\TODO{Mainida paremaid algoritme}
\TODO{Viidata korrektsusele}

Eelnevas näites oleks võrratuste ja võrrandite süsteemid järgnevad:
\[
	\begin{cases}
		x_1 \sqgeq \top \\
		x_2 \sqgeq x_1 \\
		x_3 \sqgeq x_1 \\
		x_4 \sqgeq \{5\} \\
		x_5 \sqgeq \{3\} \\
		\begin{rcases*}
			x_6 \sqgeq x_4 \\
			x_6 \sqgeq x_5
		\end{rcases*} \Rightarrow x_6 \sqgeq x_4 \sqcup x_5 \\
		x_7 \sqgeq x_6
	\end{cases}
	\qquad \text{ja} \qquad
	\begin{cases}
		x_1 = \top \\
		x_2 = x_1 \\
		x_3 = x_1 \\
		x_4 = \{5\} \\
		x_5 = \{3\} \\
		x_6 = x_4 \sqcup x_5 \\
		x_7 = x_6
	\end{cases}.
\]
Viimase iteratiivne lahendamine on näidatud tabelis~\ref{tab:itersolve}. On näha, et algoritmiline analüüs jõudis oodatud tulemuseni.

\begin{table}[h]
	\caption{Näiteprogrammi (joonisel~\ref{lst:if}) analüüsi süsteemi iteratiivse lahendamise sammud ja lahend.}
	\centering
	$\begin{tabu}{c|c|c|c|c|c}
		\hline
		i & 0 & 1 & 2 & 3 & 4 \\
		\hline
		x_1 & \bot & \top & \top & \top & \multirow{7}{*}{sama} \\
		x_2 & \bot & \bot & \top & \top &  \\
		x_3 & \bot & \bot & \top & \top &  \\
		x_4 & \bot & \{5\} & \{5\} & \{5\} &  \\
		x_5 & \bot & \{3\} & \{3\} & \{3\} &  \\
		x_6 & \bot & \bot & \{3, 5\} &  \{3, 5\} &  \\
		x_7 & \bot & \bot & \bot & \{3, 5\} &  \\
		\hline
	\end{tabu}$
	\label{tab:itersolve}
\end{table}

\subsection{Kujutusdomeen}
\TODO{\textit{mapdomain} --- funktsioondomeen? kujutusdomeen?}
Olgu $\Var$ programmi muutujate hulk ja $\Val$ domeen, milles vaadeldakse ühe muutuja seisundit. Sel juhul saab vaadelda abstraktsete muutujate väärtustuste domeeni~\cite[45]{seidl_foundations}
\[
	\mathbb{D} = (\Var \to \Val)_\bot = (\Var \to \Val) \cup \{\bot\}.
\]
Domeeni elementideks on kujutused muutujate hulgast abstraktsete väärtuste hulka, mis on väga analoogilised konkreetsete muutujate väärtustustega funktsionaalselt kirjeldatuna. Element $\bot$ on tehislikult lisatud, et domeen moodustaks täieliku võre, ja tähendab hetkel teadaolevalt saavutamatut programmi punkti. Osaline järjestus selles domeenis on defineeritud järgnevaga:
\[
	D_1 \sqleq D_2 \quad\Longleftrightarrow\quad D_1 = \bot \quad\lor\quad \forall x \in \Var\; D_1(x) \sqleq D_2(x).
\]
\TODO{Tehted kujutustel, $\top$?}

Eelnevas näites $\Var = \{\texttt{x}, \texttt{y}\}$ ja jätkamiseks sobib juba nähtud $\Val = \powerset{\mathbb{Z}}$. Analüüsides programmi jooniselt~\ref{lst:if} nüüd selles domeenis, saame seisundid:
\begin{itemize}
	\item Punktides 1, 2 ja 3: $\{ \texttt{x} \mapsto \top, \texttt{y} \mapsto \top \}$.
	\item Punktis 4: $\{ \texttt{x} \mapsto \{5\}, \texttt{y} \mapsto \top \}$.
	\item Punktis 5: $\{ \texttt{x} \mapsto \{3\}, \texttt{y} \mapsto \top \}$.
	\item Punktis 6: $\{ \texttt{x} \mapsto \{3, 5\}, \texttt{y} \mapsto \top \}$.
	\item Punktis 7: $\{ \texttt{x} \mapsto \{3, 5\}, \texttt{y} \mapsto \{4, 6\} \}$, sest muutuja \texttt{y} on avaldatud \texttt{x}-i kaudu, mis on juba analüüsitud.
	\TODO{Abstraktne liitmistehe}
\end{itemize}

Siit selgubki, et väikese vaevaga on võimalik lihtsam ühte muutujat korraga kirjeldav domeen laiendada kõigile muutujatele korraga. Seejuures muutub võimalikuks järgida andmete liikumist muutujate vahel, mis vastab juba paremini andmevooanalüüsi nimele.

Sellegipoolest pole vaadeldu praktiliselt teostatav, sest võimalike väärtuste hulk võib olla lõpmatu ja seejuures ka ebatriviaalne. Üldiselt pole võimalik selliseid hulki programmis kirjeldada ja nendega opereerida. Seetõttu loobutakse ülimast täpsusest suvaliste hulkade kujul ja kasutatakse ebatäpsemaid domeene väärtuste kirjeldamiseks, mida on võimalik analüsaatorisse implementeerida. Üheks variandiks on vaadelda väärtuste lõike.

\subsection{Intervalldomeen}
Intervalldomeen on domeen, milles täisarvude väärtuste abstraheerimiseks kasutatakse arvtelje lõike.

\begin{definition}
\emph{Intervalldomeeniks}~\cite[55]{seidl_foundations} nimetatakse hulka
\[
	\mathbb{I} = \{ [l, u] \mid l \in \mathbb{Z} \cup \{-\infty\}, u \in \mathbb{Z} \cup \{+\infty\}, l \leq u \},
\]
millel on osaline järjestus
\[
	[l_1, u_1] \sqleq [l_2, u_2] \quad\Longleftrightarrow\quad l_2 \leq l_1 \land u_1 \leq u_2.
\]
\end{definition}

Sellises domeenis
\begin{align*}
	[l_1, u_1] \sqcup [l_2, u_2] &= [\min\{l_1, l_2\}, \max\{u_1, u_2\}], \\
	[l_1, u_1] \sqcap [l_2, u_2] &= [\max\{l_1, l_2\}, \min\{u_1, u_2\}],\quad \text{kui } \max\{l_1, l_2\} \leq \min\{u_1, u_2\}.
\end{align*}
\TODO{Joonis intervallide $\sqcup, \sqcap$ kohta \textit{a la} Seidl}
Kuna alumine raja on ainult tinglikult defineeritud, siis see pole täielik võre. See pole probleem, kuna pisut täiendatud domeen $\mathbb{I}_\bot = \mathbb{I} \cup \{\bot\}$ osutub täielikuks võreks.
Lõigu otspunktides on lubatud vastavad lõpmatust kirjeldavad väärtused, mis võimaldavad rääkida selles domeenis suurimast elemendist $\top = [-\infty, +\infty]$.

Lõik $[l, u]$ kirjeldab täisarvu $z$ parajasti siis, kui $l \leq z \leq u$.

Valides eelnevas joonisel~\ref{lst:if} tehtud näites $\Var = \mathbb{I}$, saame seisundid analoogiliselt:
\begin{itemize}
	\item Punktides 1, 2 ja 3: $\{ \texttt{x} \mapsto \top, \texttt{y} \mapsto \top \}$.
	\item Punktis 4: $\{ \texttt{x} \mapsto [5, 5], \texttt{y} \mapsto \top \}$.
	\item Punktis 5: $\{ \texttt{x} \mapsto [3, 3], \texttt{y} \mapsto \top \}$.
	\item Punktis 6: $\{ \texttt{x} \mapsto [3, 5], \texttt{y} \mapsto \top \}$, kus \texttt{x}-i seisundi saab avaldada harudes olevatest: $[3, 3] \sqcup [5, 5] = [3, 5]$.
	\item Punktis 7: $\{ \texttt{x} \mapsto [3, 5], \texttt{y} \mapsto [4, 6] \}$.
\end{itemize}


\end{document}